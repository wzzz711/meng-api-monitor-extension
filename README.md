# MENG 接口监听器

一款为开发者设计的强大浏览器扩展，用于监控、审查和记录网页发出的所有 `XMLHttpRequest` 和 `Fetch` API 请求。它提供了一个无侵扰的悬浮窗和一个详细的请求查看器，旨在完美兼容那些会修改原生浏览器 API 的复杂单页应用。

## ✨ 功能特性

-   **实时拦截**: 即时捕获页面上的 `XMLHttpRequest` 和 `Fetch` 请求。
-   **页面悬浮窗**: 一个可拖动的、非侵入式的悬浮窗，实时显示捕获到的请求数量。
-   **请求详情查看器**: 一个专门的查看页面，让你能够审查每个请求的详细信息，包括 URL、方法、请求体和完整的响应内容。
-   **稳定且兼容**: 经过精心设计，以防止与其他同样会修改网络接口的脚本发生冲突，有效避免了无限递归等常见陷阱。
-   **会话级存储**: 所有捕获的数据都与当前标签页绑定，关闭标签页时会自动清除，确保了用户隐私且不会造成数据冗余。

## 🏗️ 架构概览

![时序图](./sequenceDiagrams/system.png)

本扩展基于一个标准的四部分架构，这也是需要与网页进行深度交互的 Chrome 扩展所普遍采用的强大模式。

-   **`popup.js` (UI 控制器)**: 用户交互界面，用于开始/停止监控、清空记录和打开查看器。
-   **`content.js` (通信桥梁)**: 被注入到目标页面中。它扮演着桥梁的角色，负责与其他部分通信，并管理页面上的悬浮窗。
-   **`injected.js` (核心探针)**: 拦截逻辑的核心。它由内容脚本注入到页面自身的 JavaScript 上下文中，从而获得了修改 `XMLHttpRequest` 和 `fetch` 原型的必要权限。
-   **`background.js` (控制大脑)**: 扩展的后台服务。它管理全局状态，使用 `chrome.storage` 处理数据存储，并协调不同标签页之间的通信。

## 🚀 如何安装

1.  克隆或下载此仓库的 ZIP 文件并解压。
2.  打开 Chrome 浏览器并导航至 `chrome://extensions`。
3.  打开右上角的"开发者模式"开关。
4.  点击"加载已解压的扩展程序"按钮。
5.  选择刚刚解压的项目文件夹。现在"MENG 接口监听器"应该会出现在你的扩展列表中。

---

> ***开发者备忘录:*** *以下各节深入探讨了此扩展在开发过程中遇到的核心技术挑战、设计决策和解决方案。普通用户无需阅读此部分内容。*

## 🛠️ 技术备忘：兼容性问题的解决方案

开发此工具最大的挑战是确保与现代复杂网页应用（如某书文档）的兼容性。这些应用本身也经常会修改或"修补" (Patch) 我们需要监控的浏览器 API，一个天真的实现会导致经典的"无限递归"问题。以下是我们解决这些边界问题的思路历程。

### 1. 前置问题：复杂的调用链

要理解问题的根源，首先必须认识到我们并非在"真空"中运行。在一个复杂的单页应用中，脚本的加载和执行顺序至关重要。

**核心前提是：我们的拦截逻辑，必须在目标网页自身的脚本逻辑之后执行。** 这一顺序是由浏览器处理静态与动态脚本的方式决定的，即便我们将扩展配置为 `run_at: "document_start"`：

*   **`content.js` 的抢先执行**: 配置为 `document_start` 确保了我们的 `content.js` 脚本在页面的 DOM 构建和其他脚本执行前，尽可能早地运行。它像一个"信使"，第一时间到达现场。
*   **`injected.js` 的动态注入**: `content.js` 的任务是动态创建一个 `<script>` 标签，将我们的核心拦截逻辑 `injected.js` 注入到页面中。
*   **静态脚本的优先权**: 浏览器在解析 HTML 文档时，会优先执行遇到的静态 `<script>` 标签（即写在 HTML 文件里的脚本）。我们动态创建并插入的脚本，会被放入待执行队列，但通常晚于页面已有的静态核心脚本。

这种"静态优先于动态"的机制，导致了"应用先运行，我们后运行"的最终结果，使得我们能够拦截到被上游框架修改过的 API，并构建起我们的调用链：

1.  **某书先上场**: 浏览器解析 HTML，执行其头部的静态核心脚本。该脚本保存了浏览器**最原始**的 `open` 方法（我们称之为 `native_open`），并用自己的 `moushu_open` 版本替换了 `XMLHttpRequest.prototype.open`。
2.  **我们后上场**: 随后，我们动态注入的 `injected.js` 才被执行。我们保存的"原始方法"，其实已经是被某书包装过的 `moushu_open`。然后我们再用 `our_open` 替换它。

这就形成了一个调用链：**`our_open` -> `moushu_open` -> `native_open`**。我们的每一次拦截，实际上都处在这个链条的最顶端。

### 2. 核心问题：污染"纯净"对象导致的无限递归

在上述调用链的基础上，当我们试图拦截请求时，真正的冲突便产生了。其根本原因在于**对象所有权和意外的副作用**。

#### 破坏机制的统一模型

为了完整地理解整个过程，我们可以将"对象封装"和"原型修改"这两个概念，用一个统一的、更完整的伪代码模型来展现：

```javascript
// == 第一步: 某书的封装与修补 ==
// 这是某书的脚本，它在我们的脚本之前执行

// 1. 保存浏览器最原始的 open 方法
const native_open = XMLHttpRequest.prototype.open;

// 2. 用自己带防御机制的 moushu_open 替换原型上的 open
XMLHttpRequest.prototype.open = function moushu_open(method, url, ...args) {
  // 决策点：判断是否需要执行安全检查
  if (this.需要进行环境安全检查()) {
    // 【需要检查】：执行"回头确认"，再次调用 this.open()
    // 期望这次调用是良性的，从而通过检查
    this.open(method, url, ...args); 
    return;
  } else {
    // 【无需检查】：直接调用私藏的原始方法办正事
    return native_open.apply(this, arguments);
  }
};

// 3. 某书在业务逻辑中使用一个 Manager 类来发请求
class MoushuRequestManager {
  constructor() {
    this.internalXhr = new XMLHttpRequest();
  }
  open(method, url) {
    // 关键：当 manager.open() 被调用时，它内部调用了 internalXhr.open()。
    // 这个调用命中的，是上面刚刚被替换的、带防御机制的 moushu_open。
    // 同时，moushu_open 内部的 `this`，正确地指向了 internalXhr 实例。
    this.internalXhr.open(method, url);
  }
  // ... 其他方法
}

// == 第二步: 我们的拦截 ==
// 这是我们的 injected.js，在某书脚本之后执行

// 1. 保存我们看到的 "原始" open，实际上已经是 moushu_open
const originalProtoOpen = XMLHttpRequest.prototype.open;

// 2. 用我们自己的 our_open 再次替换原型
XMLHttpRequest.prototype.open = function our_open(method, url, ...args) {
  // 重入守卫
  if (this._monitor_is_opening) {
    return originalProtoOpen.apply(this, arguments);
  }
  this._monitor_is_opening = true;

  // 我们的监控逻辑
  this._monitor_method = method;
  this._monitor_url = url;
  
  // 调用被我们保存的、实际上是 moushu_open 的方法
  const result = originalProtoOpen.apply(this, arguments);
  
  delete this._monitor_is_opening;
  return result;
};
```

**时序图解：冲突与守卫的完整流程**

![时序图](./sequenceDiagrams/open.png)

在这个统一的模型下，整个冲突的产生就非常清晰了：
1.  我们通过 `our_open` 拦截了 `MoushuRequestManager` 的调用。
2.  我们在 `this` (`internalXhr` 实例)上添加了 `_monitor_` 属性。
3.  我们调用 `originalProtoOpen`，将控制权交给了 `moushu_open`。
4.  `moushu_open` 发现了环境异常，触发了它的防御机制——"回头确认"，再次调用 `this.open()`。
5.  这个调用，再次命中了我们处于调用链最顶端的 `our_open`，从而产生了递归。

#### 守卫如何解决

我们最终的"重入守卫"方案，恰好完美地应对了 `moushu_open` 的"回头确认"测试：
```javascript
if (this._monitor_is_opening) {
  // 在"回头确认"时，不产生任何副作用，直接将球踢回给 moushu_open
  return originalProtoOpen.apply(this, arguments); 
}
```
当我们的 `our_open` 因"回头确认"而被递归调用时，守卫生效。它什么都不做，不添加任何属性，直接再次调用 `originalProtoOpen` (即 `moushu_open`)。`moushu_open` 看到这次调用没有产生新的副作用，便认为安全检查通过，于是调用 `native_open`，从而打破了循环。

### 3. 核心解惑：为什么 `moushu_open` 要"回头确认"？

这个"回头"的动作，并非无心之失，而是一种在复杂前端应用中常见的**防御性编程**。它不直接调用私藏的 `native_open`，是出于两个核心考量：1) **环境安全检查**：确保在它执行的瞬间，没有其他脚本正在干扰 `xhr` 对象。2) **逻辑统一**：确保所有请求，即使是它内部发起的，也遵循唯一的、标准的处理流程。

某书的工程师需要确保，在 `open` 到 `send` 之间，它设置在 `xhr` 实例上的重要属性（如 `token`、`headers`）没有被其他脚本（如广告、分析工具或其他扩展）意外地修改或清除。这个"回头确认"就是它的**环境安全检查**机制。

我们的守卫，本质上是**帮助并兼容了对方的防御机制**，而不是与之对抗。

### 4. 深度解惑：为什么 `_monitor_is_opening` 标志本身是安全的？

这是一个非常关键的问题：既然添加属性是一种"污染"，为什么添加 `_monitor_is_opening` 这个属性，就不会被上游框架（如"某书"）的防御机制视为"恶意污染"？

答案在于，上游框架的防御机制，其检查的重点很可能不是 **"环境当前是否有未知属性"**，而是 **"调用 `open` 这个行为是否会引入新的、非预期的副作用"**。

`_monitor_is_opening` 这一标志恰好帮助我们通过了这种**行为测试**：

1.  **区分状态数据与流程控制标志**：
    *   **`_monitor_method` / `_monitor_url`**：是**状态数据**。它们需要跨函数（从 `open` 到 `send`）存在，承载着核心业务信息。在 `open` 阶段就植入这类数据，更容易被视为一种有风险的"污染"。
    *   **`_monitor_is_opening`**：是一个**流程控制标志**。它的生命周期极短（"阅后即焚"），不携带业务数据，其唯一作用就是给我们的代码自己看，用于斩断递归，避免无限循环。

2.  **通过"回头确认"的行为测试**：当上游框架注意到环境异常（或 `open` 被重写），它发起"回头确认"调用，本质是在进行一次**安全行为测试**。
    *   **测试前**：环境可能已被我们的首次调用"污染"（存在 `_monitor_is_opening` 等属性）。
    *   **测试中**：它再次调用 `this.open()`。此时，我们的守卫被触发，函数**无副作用**（不添加或修改任何属性）且**快速返回**。
    *   **测试结论**：`open` 函数虽然被替换，但其递归调用行为是**幂等且良性的**，不会引入进一步的污染。测试通过。

3.  **信任但有风险的君子协定**：我们的代码能够运行，最终是建立在一个双向的信任基础上的：
    *   **我们对上游的信任**：我们必须相信，上游框架（如"某书"）遵循了基本的软件设计原则。它的 `open` 方法作为一个整体，对外必须是 **"无状态破坏性的"**。即，它内部的安全检查，无论采用何种机制（如快照对比或临时删除恢复），都不能永久性地破坏 `XMLHttpRequest` 对象上由其他脚本设置的、需要传递到 `send` 阶段的状态。如果它违反了这一原则，那么不仅是我们的插件，它自身的业务逻辑也很可能崩溃。
    *   **上游对我们的信任**：我们也必须表现得像一个"良好市民"。我们的守卫逻辑，恰恰是在向上游框架证明：我们的代码是"良性"的，不会在它的安全检查期间引入意外的副作用。

    因此，`_monitor_is_opening` 不仅不是"恶意污染"，反而是我们向外部环境证明自身"品行良好"的关键工具，是我们得以在这个信任协定下生存的"通行证"。

### 5. 君子协定 vs 主动欺骗

既然我们理解了它的防御机制，能否主动"欺骗"并绕过它？某书的防御是否本身就不完善？

**关于"主动欺骗"**

理论上，我们完全可以做到。我们可以在记录完 API 调用后，再小心地抹除掉所有我们添加在 `xhr` 对象上的属性（包括我们的守卫标记），将一个"干净"的对象交还给某书的脚本。这就像一个高明的间谍，在完成任务后将现场恢复原状。

但我们选择了**不这么做**。因为这种"主动欺骗"会使我们的扩展与某书的内部实现**过度耦合**。一旦某书更新，调整了它的检查逻辑，我们的扩展就可能立刻失效。

我们当前的"重入守卫"方案，更像是一种**君子协定**式的**被动兼容**。它不对对方的内部实现做任何假设，只遵循"凡是重入，皆为可疑，直接放行"的通用原则。这使得我们的方案更加健壮，维护成本也更低。

**关于某书防御的"不完善"**

某书的防御机制在"健康检查失败"后的降级策略存在缺陷。其无限重试行为，是基于一种乐观但天真的假设——即外部干扰是瞬时的，多试一次可能就会恢复正常。

这个策略的根本问题是缺少"熔断"机制：它没有设置重试上限。在面对我们插件这种持久性的"干扰源"时，便会陷入无限递归，最终导致页面崩溃。因此，这并非一个健壮的设计。 